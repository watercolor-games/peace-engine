using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Linq;using System.Reflection;using System.Text;using System.Threading.Tasks;using Plex.Objects.FFI;using System.Security.Cryptography;namespace Plex.Objects{    /// <summary>    /// Mirror, mirror on the wall.    /// ReflectMan is the core engine that makes Plex modular and    /// moddable. Implementations of IFFI find types which are added to    /// ReflectMan's central IEnumerable. Any part of the game can find    /// implementations of an interface it wants by performing LINQ    /// queries on said IEnumerable.    /// </summary>    public static class ReflectMan    {        /// <summary>        /// A <see cref="System.Collections.ObjectModel.ReadOnlyCollection" /> containing all of the types loaded.        /// </summary>        public static ReadOnlyCollection<Type> Types { get; private set; }                // This static initialiser calls the implementations of IFFI        // and combines their output into the Types collection.        static ReflectMan()        {            // All found types that implement IFFI. It's initialised            // to contain DotNet because we need something to find other            // implementations with.            List<Type> ffis = new List<Type> { typeof(DotNet) };                        // All found types. This list will be converted to a            // read-only collection and placed in Types.            List<Type> types = new List<Type>();            while (ffis.Count > 0) // recurse            {                try                {                    IEnumerable<Type> newtypes = ((IFFI) Activator.CreateInstance(ffis[0])).GetTypes();                    types.AddRange(newtypes);                                        // FFIs can find more FFIs. Isn't it beautiful?                    ffis.AddRange(newtypes.Where(t => t.GetInterfaces().Contains(typeof(IFFI))));                    Console.WriteLine($"{ffis[0].Name} successfully loaded types.");                }                catch (Exception ex)                {                    // We can stifle any errors because they're most                    // likely 3rd-party modder mistakes that don't need                    // to bring down the whole game, but it's always a                    // good idea to tell the user what's going on. We're                    // Watercolor Games, not Microsoft, after all.                    Console.WriteLine($"{ffis[0].Name} failed to load types.");                    Console.WriteLine(ex);                }                ffis.RemoveAt(0); // don't re-call            }                        // We make it read-only so its consumers can't modify it            // unexpectedly. ReflectMan previously made it only            // accessible via a get-only property but that's not good            // enough for collections.            Types = Array.AsReadOnly(types.ToArray());        }        /// <summary>        /// Converts a Type to 64 bytes which can be used to retrieve it        /// even after a program restart.        /// </summary>        /// <returns>The bytes.</returns>        /// <param name="t">The type to be serialised.</param>        public static byte[] ToBytes(this Type t)        {            using (var sha = new SHA512Managed())                return sha.ComputeHash(Encoding.UTF8.GetBytes(t.AssemblyQualifiedName));        }        /// <summary>        /// Retrieves a Type from bytes produced by ToBytes().  The Type        /// must be known to ReflectMan.        /// </summary>        /// <returns>The type.</returns>        /// <param name="data">The bytes to be deserialised.</param>        public static Type FromBytes(byte[] data)        {            using (var sha = new SHA512Managed())                return Types.First(t => sha.ComputeHash(Encoding.UTF8.GetBytes(t.AssemblyQualifiedName)).SequenceEqual(data));        }    }}